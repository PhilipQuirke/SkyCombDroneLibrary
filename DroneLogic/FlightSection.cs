// Copyright SkyComb Limited 2023. All rights reserved. 
using SkyCombDrone.DroneModel;
using SkyCombGround.CommonSpace;


// Relates to data we can load from the log generated by the drone during flight
namespace SkyCombDrone.DroneLogic
{
    // Raw input data about a flight section
    // Contains all useful attributes provided in drone flight data logs e.g. when and where it took place
    public class FlightSection : FlightSectionModel
    {
        public Drone Drone { get; }


        public FlightSection(Drone drone, int sectionId) : base(sectionId)
        {
            Drone = drone;
        }


 


        // Calculate location of drone at this flight section in local NorthingM/EastingM.
        // Relative origin is bottom left of box.
        // Absolute origin is FlightSections.MinGlobalLocation.Latitude/Longitude
        public void CalculateSettings_LocationM(FlightSections sections)
        {
            if (this.GlobalLocation.Specified)
            {
                DroneLocnM = sections.GlobalToDroneLocation(this.GlobalLocation);

                // northingM / eastingM are normally in the range 0 to 5000 (5km)
                Assert(DroneLocnM.NorthingM >= 0, "FlightSection.CalculateSettings_LocationM: Negative northingM");
                Assert(DroneLocnM.EastingM >= 0, "FlightSection.CalculateSettings_LocationM: Negative eastingM");
                // 1000km is silly. Likely a NZGTM2000 value has been mixed with a DroneLocation
                Assert(DroneLocnM.NorthingM < 1000000, "FlightSection.CalculateSettings_LocationM: Massive northingM");
                Assert(DroneLocnM.EastingM < 1000000, "FlightSection.CalculateSettings_LocationM: Massive eastingM");
            }
            else
                DroneLocnM = new(0, 0);
        }
    };


    // Raw input data about a flight 
    public class FlightSections : FlightSectionsModel
    {
        // The list of flight sections sorted in time order.
        // The index is the number of SectionMinMs units since the flight started.
        // The index sequence will be 1, 2, 3, etc. Occassional gaps do occur - but they are rare, and only if the drone flight log has time gaps.
        public SortedList<int, FlightSection> Sections { get; }


        public FlightSections(List<string>? settings = null) : base(settings)
        {
            Sections = new();
        }


        public void SetTardisMaxKey() 
        {
            TardisMaxKey = 0;
            if (Sections.Count > 0)
                TardisMaxKey = Sections.Keys[Sections.Count - 1];
        }


        // Return the child FlightStep
        public override TardisModel? GetTardisModel(int index) 
        {
            FlightSection? answer = null;
            Sections.TryGetValue(index, out answer);
            return answer;    
        }


        // Add the flight section, indexed by SectionMinMs units
        public void AddSection(FlightSection thisSection, FlightSection? prevSection)
        {
            thisSection.CalculateSettings_TimeMs(prevSection);
            Sections.Add(thisSection.TardisId, thisSection);
            SetTardisMaxKey();
        }


        // Does this drone provide Yaw data?
        public bool HasYawData()
        {
            foreach ((_, FlightSection thisSection) in Sections)
                if (thisSection.YawDeg != UnknownValue)
                    return true;

            return false;
        }


        // Does this drone provide Pitch data?
        public bool HasPitchData()
        {
            foreach ((_, FlightSection thisSection) in Sections)
                if (thisSection.PitchDeg != UnknownValue)
                    return true;

            return false;
        }


        // Calculate % overlap of two FlightDatas
        // Used to determine if the two FlightDatas relate to same physical flight (one optical and one thermal).
        public static int PercentOverlap(FlightSections? flight1, FlightSections? flight2)
        {
            if (flight1 == null || flight2 == null)
                return BaseConstants.UnknownValue;

            if (flight1.MinDateTime.Date != flight2.MinDateTime.Date)
                return 0; // Different days

            if (flight1.MinDateTime > flight2.MaxDateTime || flight2.MinDateTime > flight1.MaxDateTime)
                return 0;

            var f1min = flight1.MinDateTime.ToFileTime();
            var f1max = flight1.MaxDateTime.ToFileTime();
            var f2min = flight2.MinDateTime.ToFileTime();
            var f2max = flight2.MaxDateTime.ToFileTime();

            var maxMin = Math.Max(f1min, f2min);
            var minMax = Math.Min(f1max, f2max);
            var minMin = Math.Min(f1min, f2min);
            var maxMax = Math.Max(f1max, f2max);

            double maxDuration = maxMax - minMin;
            double overlap = 100.0 * (minMax - maxMin) / maxDuration;
            return (int)overlap;
        }


        public void AssertGood_GlobalLocations()
        {
            Assert(MinGlobalLocation != null, "FlightSections.AssertGood: No MinGlobalLocation");
            Assert(MaxGlobalLocation != null, "FlightSections.AssertGood: No MaxGlobalLocation");
            Assert(MinGlobalLocation.Longitude < MaxGlobalLocation.Longitude + Epsilon, "FlightSections.AssertGood: Longitude misordered");
            Assert(MinGlobalLocation.Latitude < MaxGlobalLocation.Latitude + Epsilon, "FlightSections.AssertGood: Latitude misordered");
            MinGlobalLocation.AssertNZ();
            MaxGlobalLocation.AssertNZ();
        }
        public void AssertGood()
        {
            Assert(FileName != "", "FlightSections.AssertGood: No FileName");
            AssertGood_GlobalLocations();
            AssertGood_SizeM();
        }


        // Calculate relative location (in NorthingM/EastingM)
        // of the specified global location.
        // Relative origin is bottom left of box.
        // Absolute origin is FlightSections.MinGlobalLocation.Latitude/Longitude
        public DroneLocation GlobalToDroneLocation(GlobalLocation globalLocation)
        {
            float northingM = 0;
            float eastingM = 0;

            if (globalLocation.Specified)
            {
                var deltaLatitude = MaxGlobalLocation.Latitude - MinGlobalLocation.Latitude;
                var deltaLongitude = MaxGlobalLocation.Longitude - MinGlobalLocation.Longitude;

                if (Math.Abs(deltaLatitude) > Epsilon)
                    northingM = (float)(NorthingRangeM() *
                        (globalLocation.Latitude - MinGlobalLocation.Latitude) / deltaLatitude);

                if (Math.Abs(deltaLongitude) > Epsilon)
                    eastingM = (float)(EastingRangeM() *
                        (globalLocation.Longitude - MinGlobalLocation.Longitude) / deltaLongitude);
            }

            return new(northingM, eastingM);
        }


        // Calculate the Min/MaxGlobalLocation and Min/MaxAltitude values from the FlightSection data
        // This function is an alternative to the above LoadSettings function.
        public void CalculateSettings()
        {
            // From the raw input data, calculate some deltas and cumulative values
            FlightSection? prevSection = null;
            foreach ((int thisKey, FlightSection thisSection) in Sections)
            {
                if (thisSection.GlobalLocation.Specified)
                {
                    if (MinGlobalLocation == null)
                    {
                        MinGlobalLocation = new(thisSection.GlobalLocation);
                        MaxGlobalLocation = new(thisSection.GlobalLocation);
                    }
                    else
                    {
                        MinGlobalLocation.Latitude = Math.Min(MinGlobalLocation.Latitude, thisSection.GlobalLocation.Latitude);
                        MinGlobalLocation.Longitude = Math.Min(MinGlobalLocation.Longitude, thisSection.GlobalLocation.Longitude);

                        MaxGlobalLocation.Latitude = Math.Max(MaxGlobalLocation.Latitude, thisSection.GlobalLocation.Latitude);
                        MaxGlobalLocation.Longitude = Math.Max(MaxGlobalLocation.Longitude, thisSection.GlobalLocation.Longitude);
                    }
                }
                prevSection = thisSection;
            }
            AssertGood_GlobalLocations();


            // Calculate encompassing box size in local coordinate system - NorthingM/EastingM
            // Assume that the box flown by drone is sufficiently small that the longitude/latitude
            // conversion to meters is effectively constant across the box area.
            MinDroneLocnM = new(0, 0);
            MaxDroneLocnM = RelativeLocation.DistanceM(MinGlobalLocation, MaxGlobalLocation);


            prevSection = null;
            foreach ((int _, FlightSection thisSection) in Sections)
            {
                thisSection.CalculateSettings_LocationM(this);
                thisSection.CalculateSettings_LinealM(prevSection);
                thisSection.CalculateSettings_DeltaYawDeg(prevSection);

                prevSection = thisSection;
            }


            ResetTardis();
            foreach (var thisSection in Sections)
                SummariseTardis(thisSection.Value);
            AssertGood_SizeM();
        }
    }
}